-- @var class var for lib
local Cache = {}

--- Lookup of missing class members
-- @param string used for lookup of member
-- @return any
function Cache:__index( key ) -- luacheck: no self
	return Cache[key]
end

--- Call on instance
-- This is an alternative interface for maintaining the cached value.
-- @param string used for lookup of cached value
-- @param callback used for construction of value
-- @param varargs passed to the callback
-- @return cached value or a value generated by the callback
function Cache:__call( key, func, ... )
	if self:exists( key ) then
		if self:isValid( key ) then
			return self:touch( key )
		end

		self:remove( key )
	end

	local result = { pcall( func, ... ) }

	if not result[1] then
		error( result[2], 2 ) -- should not pass this â€“ early return
	end

	table.remove( result, 1 )
	return self:insert( key, unpack( result ) ):get( key )
end

--- Create a new instance
-- @param table for options (optional)
function Cache.create( ... )
	local self = setmetatable( {}, Cache )
	return self:_init( ... )
end

--- Initialize a new instance
-- @param table for options (optional)
function Cache:_init( opts )
	opts = opts or {}
	self._os = opts.os or os       -- Ref to os lib so it can be overridden while testing
	self._size = opts.size or 16   -- Size of the LRU cache for data
	self._time = opts.time or 60   -- Time before purging the data
	self._order = opts.order or {} -- Sequence of entries according to least use
	self._data = opts.data or {}   -- Hash of key-values pairs, where values are a table
	return self
end

--- The depth of the internal structure
-- This value reflects the depth of the "order" structure.
-- @return number saying how deep the internal structure is
function Cache:depth()
	return #self._order
end

--- Consistence check
-- Verify the internal structure.
-- @return boolean for consistency
function Cache:isConsistent()
	local count = 0
	for _,k in ipairs( self._order ) do
		count = count + 1
		if not self._data[k] then
			return false
		end
	end
	for _,_ in pairs( self._data ) do
		count = count - 1
	end
	return count == 0
end


--- Is the internal structure empty
-- This value reflects the depth of the "order" structure.
-- @return boolean saying whether the "order" is empty
function Cache:isEmpty()
	return #self._order == 0
end

--- Is the internal structure above the maximum number
-- @return boolean saying whether the limit is reached
function Cache:isMax()
	return #self._order > self._size
end

--- Cache a given entry
-- This can also be false, in case it doesn't exist.
-- @param string key for lookup
-- @param varargs to be stored
-- @return self or value timestamp -pair
function Cache:insert( key, ... )
	assert( key )
	--assert( value ~= nil )

	local now = self._os.time()

	if self:isMax() then
		local tmp = table.remove( self._order, self._size )
		if tmp then
			self._data[ tmp ] = nil
		end
	end

	table.insert( self._order, 1, key )
	local values = { { ... }, now }
	self._data[ key ] = values

	return self
end

--- Remove a given entry
-- @param string key for lookup
-- @return self or found entry, should be same as key
function Cache:remove( key )
	assert( key )

	for i,v in ipairs(self._order) do
		if key == v then
			local tmp = table.remove( self._order, i )
			self._data[ tmp ] = nil
			break
		end
	end

	return self
end

--- Is the cached entry still considered valid
-- This checks if the key is for an entry that is still within cache time.
-- @param string key for lookup
-- @return boolean saying whether the limit is reached
function Cache:isValid( key )
	assert( key )

	local now = self._os.time()
	local item = self._data[ key ]

	if item == nil then
		return false
	end

	return self._os.difftime( now, item[2], now ) < self._time
end

--- Does the cached entry exist
-- @param string key for lookup
-- @return boolean saying whether the entry is cached
function Cache:exists( key )
	return not not self._data[ key ]
end

--- Touch the entry
-- This mark the entry as still in use, moving it up front again.
-- @param string key for lookup
-- @return self or found entry, should be same as key
function Cache:touch( key )
	assert( key )

	for i, k in ipairs( self._order ) do
		if k == key then
			table.remove( self._order, i )
			break -- important!
		end
	end
	table.insert( self._order, 1, key )

	return self
end

--- Retrieve an entry
-- Will return false in case it's known to not exist
-- and nil in case of a cache miss.
-- @param string key for lookup
-- @return cached values
function Cache:get( key )
	assert( key )

	if self:exists( key ) and not self:isValid( key ) then
		self:remove( key )
	end

	local item = self._data[ key ]

	if item == nil then
		return
	end

	self:touch( key )

	return unpack( item[1] or {} )
end

-- Return the final class
return Cache